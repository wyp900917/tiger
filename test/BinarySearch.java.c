// This is automatically generated by the Tiger compiler.
// Do NOT modify!

// structures
struct intArray
{
  int length;
  int *array;
};

struct BinarySearch
{
  struct BinarySearch_vtable *vptr;
};
struct BS
{
  struct BS_vtable *vptr;
  struct intArray * number;
  int  size;
};
// vtables structures
struct BinarySearch_vtable
{
};

struct BS_vtable
{
  int (*Start)(struct BS *, int);
  int (*Search)(struct BS *, int);
  int (*Div)(struct BS *, int);
  int (*Compare)(struct BS *, int, int);
  int (*Print)(struct BS *);
  int (*Init)(struct BS *, int);
};


// methods declarations
int BS_Start(struct BS *this, int sz);
int BS_Search(struct BS *this, int num);
int BS_Div(struct BS *this, int num);
int BS_Compare(struct BS *this, int num1, int num2);
int BS_Print(struct BS *this);
int BS_Init(struct BS *this, int sz);

// vtables
struct BinarySearch_vtable BinarySearch_vtable_ = 
{
};

struct BS_vtable BS_vtable_ = 
{
  BS_Start,
  BS_Search,
  BS_Div,
  BS_Compare,
  BS_Print,
  BS_Init
};


// methods
int BS_Start(struct BS *this, int sz)
{
  int  aux01;
  int  aux02;

  aux01 = this->vptr->Init(this, sz);
  aux02 = this->vptr->Print(this);
  if (this->vptr->Search(this, 8))
    System_out_println (1);
  else
    System_out_println (0);
  if (this->vptr->Search(this, 19))
    System_out_println (1);
  else
    System_out_println (0);
  if (this->vptr->Search(this, 20))
    System_out_println (1);
  else
    System_out_println (0);
  if (this->vptr->Search(this, 21))
    System_out_println (1);
  else
    System_out_println (0);
  if (this->vptr->Search(this, 37))
    System_out_println (1);
  else
    System_out_println (0);
  if (this->vptr->Search(this, 38))
    System_out_println (1);
  else
    System_out_println (0);
  if (this->vptr->Search(this, 39))
    System_out_println (1);
  else
    System_out_println (0);
  if (this->vptr->Search(this, 50))
    System_out_println (1);
  else
    System_out_println (0);
  return 999;
}
int BS_Search(struct BS *this, int num)
{
  int  bs01;
  int  right;
  int  left;
  int  var_cont;
  int  medium;
  int  aux01;
  int  nt;

  aux01 = 0;
  bs01 = 0;
  right = (this->number)->length;
  right = right - 1;
  left = 0;
  var_cont = 1;
  while (var_cont)
  {
    medium = left + right;
    medium = this->vptr->Div(this, medium);
    aux01 = this->number->array[medium];
    if (num < aux01)
      right = medium - 1;
    else
      left = medium + 1;
    if (this->vptr->Compare(this, aux01, num))
      var_cont = 0;
    else
      var_cont = 1;
    if (right < left)
      var_cont = 0;
    else
      nt = 0;
  }
  if (this->vptr->Compare(this, aux01, num))
    bs01 = 1;
  else
    bs01 = 0;
  return bs01;
}
int BS_Div(struct BS *this, int num)
{
  int  count01;
  int  count02;
  int  aux03;

  count01 = 0;
  count02 = 0;
  aux03 = num - 1;
  while (count02 < aux03)
  {
    count01 = count01 + 1;
    count02 = count02 + 2;
  }
  return count01;
}
int BS_Compare(struct BS *this, int num1, int num2)
{
  int  retval;
  int  aux02;

  retval = 0;
  aux02 = num2 + 1;
  if (num1 < num2)
    retval = 0;
  else if (!(num1 < aux02))
    retval = 0;
  else
    retval = 1;
  return retval;
}
int BS_Print(struct BS *this)
{
  int  j;

  j = 1;
  while (j < this->size)
  {
    System_out_println (this->number->array[j]);
    j = j + 1;
  }
  System_out_println (99999);
  return 0;
}
int BS_Init(struct BS *this, int sz)
{
  int  j;
  int  k;
  int  aux02;
  int  aux01;

  this->size = sz;
  this->number = (struct intArray *)malloc(sizeof(struct intArray));
  this->number->length = sz;
  this->number->array = (int *)malloc((sz)*sizeof(int));
  j = 1;
  k = this->size + 1;
  while (j < this->size)
  {
    aux01 = 2 * j;
    aux02 = k - 3;
    this->number->array[j] = aux01 + aux02;
    j = j + 1;
    k = k - 1;
  }
  return 0;
}

// main method
int Tiger_main ()
{
  struct BS *temp_1;
  System_out_println ((temp_1=((struct BS*)(Tiger_new (&BS_vtable_, sizeof(struct BS)))), temp_1->vptr->Start(temp_1, 20)));
}




