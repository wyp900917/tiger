// This is automatically generated by the Tiger compiler.
// Do NOT modify!

// structures
struct intArray
{
  int length;
  int *array;
};

struct BinaryTree
{
  struct BinaryTree_vtable *vptr;
};
struct BT
{
  struct BT_vtable *vptr;
};
struct Tree
{
  struct Tree_vtable *vptr;
  struct Tree * left;
  struct Tree * right;
  int  key;
  int  has_left;
  int  has_right;
  struct Tree * my_null;
};
// vtables structures
struct BinaryTree_vtable
{
};

struct BT_vtable
{
  int (*Start)(struct BT *);
};

struct Tree_vtable
{
  int (*Init)(struct Tree *, int);
  int (*SetRight)(struct Tree *, struct Tree *);
  int (*SetLeft)(struct Tree *, struct Tree *);
  struct Tree *(*GetRight)(struct Tree *);
  struct Tree *(*GetLeft)(struct Tree *);
  int (*GetKey)(struct Tree *);
  int (*SetKey)(struct Tree *, int);
  int (*GetHas_Right)(struct Tree *);
  int (*GetHas_Left)(struct Tree *);
  int (*SetHas_Left)(struct Tree *, int);
  int (*SetHas_Right)(struct Tree *, int);
  int (*Compare)(struct Tree *, int, int);
  int (*Insert)(struct Tree *, int);
  int (*Delete)(struct Tree *, int);
  int (*Remove)(struct Tree *, struct Tree *, struct Tree *);
  int (*RemoveRight)(struct Tree *, struct Tree *, struct Tree *);
  int (*RemoveLeft)(struct Tree *, struct Tree *, struct Tree *);
  int (*Search)(struct Tree *, int);
  int (*Print)(struct Tree *);
  int (*RecPrint)(struct Tree *, struct Tree *);
};


// methods declarations
int BT_Start(struct BT *this);
int Tree_Init(struct Tree *this, int v_key);
int Tree_SetRight(struct Tree *this, struct Tree *rn);
int Tree_SetLeft(struct Tree *this, struct Tree *ln);
struct Tree *Tree_GetRight(struct Tree *this);
struct Tree *Tree_GetLeft(struct Tree *this);
int Tree_GetKey(struct Tree *this);
int Tree_SetKey(struct Tree *this, int v_key);
int Tree_GetHas_Right(struct Tree *this);
int Tree_GetHas_Left(struct Tree *this);
int Tree_SetHas_Left(struct Tree *this, int val);
int Tree_SetHas_Right(struct Tree *this, int val);
int Tree_Compare(struct Tree *this, int num1, int num2);
int Tree_Insert(struct Tree *this, int v_key);
int Tree_Delete(struct Tree *this, int v_key);
int Tree_Remove(struct Tree *this, struct Tree *p_node, struct Tree *c_node);
int Tree_RemoveRight(struct Tree *this, struct Tree *p_node, struct Tree *c_node);
int Tree_RemoveLeft(struct Tree *this, struct Tree *p_node, struct Tree *c_node);
int Tree_Search(struct Tree *this, int v_key);
int Tree_Print(struct Tree *this);
int Tree_RecPrint(struct Tree *this, struct Tree *node);

// vtables
struct BinaryTree_vtable BinaryTree_vtable_ = 
{
};

struct BT_vtable BT_vtable_ = 
{
  BT_Start
};

struct Tree_vtable Tree_vtable_ = 
{
  Tree_Init,
  Tree_SetRight,
  Tree_SetLeft,
  Tree_GetRight,
  Tree_GetLeft,
  Tree_GetKey,
  Tree_SetKey,
  Tree_GetHas_Right,
  Tree_GetHas_Left,
  Tree_SetHas_Left,
  Tree_SetHas_Right,
  Tree_Compare,
  Tree_Insert,
  Tree_Delete,
  Tree_Remove,
  Tree_RemoveRight,
  Tree_RemoveLeft,
  Tree_Search,
  Tree_Print,
  Tree_RecPrint
};


// methods
int BT_Start(struct BT *this)
{
  struct Tree * root;
  int  ntb;
  int  nti;

  root = ((struct Tree*)(Tiger_new (&Tree_vtable_, sizeof(struct Tree))));
  ntb = root->vptr->Init(root, 16);
  ntb = root->vptr->Print(root);
  System_out_println (100000000);
  ntb = root->vptr->Insert(root, 8);
  ntb = root->vptr->Print(root);
  ntb = root->vptr->Insert(root, 24);
  ntb = root->vptr->Insert(root, 4);
  ntb = root->vptr->Insert(root, 12);
  ntb = root->vptr->Insert(root, 20);
  ntb = root->vptr->Insert(root, 28);
  ntb = root->vptr->Insert(root, 14);
  ntb = root->vptr->Print(root);
  System_out_println (root->vptr->Search(root, 24));
  System_out_println (root->vptr->Search(root, 12));
  System_out_println (root->vptr->Search(root, 16));
  System_out_println (root->vptr->Search(root, 50));
  System_out_println (root->vptr->Search(root, 12));
  ntb = root->vptr->Delete(root, 12);
  ntb = root->vptr->Print(root);
  System_out_println (root->vptr->Search(root, 12));
  return 0;
}
int Tree_Init(struct Tree *this, int v_key)
{
  this->key = v_key;
  this->has_left = 0;
  this->has_right = 0;
  return 1;
}
int Tree_SetRight(struct Tree *this, struct Tree *rn)
{
  this->right = rn;
  return 1;
}
int Tree_SetLeft(struct Tree *this, struct Tree *ln)
{
  this->left = ln;
  return 1;
}
struct Tree *Tree_GetRight(struct Tree *this)
{
  return this->right;
}
struct Tree *Tree_GetLeft(struct Tree *this)
{
  return this->left;
}
int Tree_GetKey(struct Tree *this)
{
  return this->key;
}
int Tree_SetKey(struct Tree *this, int v_key)
{
  this->key = v_key;
  return 1;
}
int Tree_GetHas_Right(struct Tree *this)
{
  return this->has_right;
}
int Tree_GetHas_Left(struct Tree *this)
{
  return this->has_left;
}
int Tree_SetHas_Left(struct Tree *this, int val)
{
  this->has_left = val;
  return 1;
}
int Tree_SetHas_Right(struct Tree *this, int val)
{
  this->has_right = val;
  return 1;
}
int Tree_Compare(struct Tree *this, int num1, int num2)
{
  int  ntb;
  int  nti;

  ntb = 0;
  nti = num2 + 1;
  if (num1 < num2)
    ntb = 0;
  else if (!(num1 < nti))
    ntb = 0;
  else
    ntb = 1;
  return ntb;
}
int Tree_Insert(struct Tree *this, int v_key)
{
  struct Tree * new_node;
  int  ntb;
  int  cont;
  int  key_aux;
  struct Tree * current_node;

  new_node = ((struct Tree*)(Tiger_new (&Tree_vtable_, sizeof(struct Tree))));
  ntb = new_node->vptr->Init(new_node, v_key);
  current_node = this;
  cont = 1;
  while (cont)
  {
    key_aux = current_node->vptr->GetKey(current_node);
    if (v_key < key_aux)
    {
      if (current_node->vptr->GetHas_Left(current_node))
        current_node = current_node->vptr->GetLeft(current_node);
      else
      {
        cont = 0;
        ntb = current_node->vptr->SetHas_Left(current_node, 1);
        ntb = current_node->vptr->SetLeft(current_node, new_node);
      }
    }
    else
    {
      if (current_node->vptr->GetHas_Right(current_node))
        current_node = current_node->vptr->GetRight(current_node);
      else
      {
        cont = 0;
        ntb = current_node->vptr->SetHas_Right(current_node, 1);
        ntb = current_node->vptr->SetRight(current_node, new_node);
      }
    }
  }
  return 1;
}
int Tree_Delete(struct Tree *this, int v_key)
{
  struct Tree * current_node;
  struct Tree * parent_node;
  int  cont;
  int  found;
  int  is_root;
  int  key_aux;
  int  ntb;

  current_node = this;
  parent_node = this;
  cont = 1;
  found = 0;
  is_root = 1;
  while (cont)
  {
    key_aux = current_node->vptr->GetKey(current_node);
    if (v_key < key_aux)
      if (current_node->vptr->GetHas_Left(current_node))
      {
        parent_node = current_node;
        current_node = current_node->vptr->GetLeft(current_node);
      }
      else
        cont = 0;
    else if (key_aux < v_key)
      if (current_node->vptr->GetHas_Right(current_node))
      {
        parent_node = current_node;
        current_node = current_node->vptr->GetRight(current_node);
      }
      else
        cont = 0;
    else
    {
      if (is_root)
        if (!(current_node->vptr->GetHas_Right(current_node)) && !(current_node->vptr->GetHas_Left(current_node)))
          ntb = 1;
        else
          ntb = this->vptr->Remove(this, parent_node, current_node);
      else
        ntb = this->vptr->Remove(this, parent_node, current_node);
      found = 1;
      cont = 0;
    }
    is_root = 0;
  }
  return found;
}
int Tree_Remove(struct Tree *this, struct Tree *p_node, struct Tree *c_node)
{
  int  ntb;
  int  auxkey1;
  int  auxkey2;
  struct Tree * temp_2;

  if (c_node->vptr->GetHas_Left(c_node))
    ntb = this->vptr->RemoveLeft(this, p_node, c_node);
  else if (c_node->vptr->GetHas_Right(c_node))
    ntb = this->vptr->RemoveRight(this, p_node, c_node);
  else
  {
    auxkey1 = c_node->vptr->GetKey(c_node);
    auxkey2 = (temp_2=p_node->vptr->GetLeft(p_node), temp_2->vptr->GetKey(temp_2));
    if (this->vptr->Compare(this, auxkey1, auxkey2))
    {
      ntb = p_node->vptr->SetLeft(p_node, this->my_null);
      ntb = p_node->vptr->SetHas_Left(p_node, 0);
    }
    else
    {
      ntb = p_node->vptr->SetRight(p_node, this->my_null);
      ntb = p_node->vptr->SetHas_Right(p_node, 0);
    }
  }
  return 1;
}
int Tree_RemoveRight(struct Tree *this, struct Tree *p_node, struct Tree *c_node)
{
  int  ntb;
  struct Tree * temp_3;

  while (c_node->vptr->GetHas_Right(c_node))
  {
    ntb = c_node->vptr->SetKey(c_node, (temp_3=c_node->vptr->GetRight(c_node), temp_3->vptr->GetKey(temp_3)));
    p_node = c_node;
    c_node = c_node->vptr->GetRight(c_node);
  }
  ntb = p_node->vptr->SetRight(p_node, this->my_null);
  ntb = p_node->vptr->SetHas_Right(p_node, 0);
  return 1;
}
int Tree_RemoveLeft(struct Tree *this, struct Tree *p_node, struct Tree *c_node)
{
  int  ntb;
  struct Tree * temp_4;

  while (c_node->vptr->GetHas_Left(c_node))
  {
    ntb = c_node->vptr->SetKey(c_node, (temp_4=c_node->vptr->GetLeft(c_node), temp_4->vptr->GetKey(temp_4)));
    p_node = c_node;
    c_node = c_node->vptr->GetLeft(c_node);
  }
  ntb = p_node->vptr->SetLeft(p_node, this->my_null);
  ntb = p_node->vptr->SetHas_Left(p_node, 0);
  return 1;
}
int Tree_Search(struct Tree *this, int v_key)
{
  int  cont;
  int  ifound;
  struct Tree * current_node;
  int  key_aux;

  current_node = this;
  cont = 1;
  ifound = 0;
  while (cont)
  {
    key_aux = current_node->vptr->GetKey(current_node);
    if (v_key < key_aux)
      if (current_node->vptr->GetHas_Left(current_node))
        current_node = current_node->vptr->GetLeft(current_node);
      else
        cont = 0;
    else if (key_aux < v_key)
      if (current_node->vptr->GetHas_Right(current_node))
        current_node = current_node->vptr->GetRight(current_node);
      else
        cont = 0;
    else
    {
      ifound = 1;
      cont = 0;
    }
  }
  return ifound;
}
int Tree_Print(struct Tree *this)
{
  struct Tree * current_node;
  int  ntb;

  current_node = this;
  ntb = this->vptr->RecPrint(this, current_node);
  return 1;
}
int Tree_RecPrint(struct Tree *this, struct Tree *node)
{
  int  ntb;

  if (node->vptr->GetHas_Left(node))
  {
    ntb = this->vptr->RecPrint(this, node->vptr->GetLeft(node));
  }
  else
    ntb = 1;
  System_out_println (node->vptr->GetKey(node));
  if (node->vptr->GetHas_Right(node))
  {
    ntb = this->vptr->RecPrint(this, node->vptr->GetRight(node));
  }
  else
    ntb = 1;
  return 1;
}

// main method
int Tiger_main ()
{
  struct BT *temp_1;
  System_out_println ((temp_1=((struct BT*)(Tiger_new (&BT_vtable_, sizeof(struct BT)))), temp_1->vptr->Start(temp_1)));
}




