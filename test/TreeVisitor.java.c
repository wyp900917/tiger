// This is automatically generated by the Tiger compiler.
// Do NOT modify!

// structures
struct intArray
{
  int length;
  int *array;
};

struct TreeVisitor
{
  struct TreeVisitor_vtable *vptr;
};
struct TV
{
  struct TV_vtable *vptr;
};
struct Tree
{
  struct Tree_vtable *vptr;
  struct Tree * left;
  struct Tree * right;
  int  key;
  int  has_left;
  int  has_right;
  struct Tree * my_null;
};
struct Visitor
{
  struct Visitor_vtable *vptr;
  struct Tree * l;
  struct Tree * r;
};
struct MyVisitor
{
  struct MyVisitor_vtable *vptr;
  struct Tree * l;
  struct Tree * r;
};
// vtables structures
struct TreeVisitor_vtable
{
};

struct TV_vtable
{
  int (*Start)(TV *);
};

struct Tree_vtable
{
  int (*Init)(Tree *, int);
  int (*SetRight)(Tree *, Tree *);
  int (*SetLeft)(Tree *, Tree *);
  struct Tree *(*GetRight)(Tree *);
  struct Tree *(*GetLeft)(Tree *);
  int (*GetKey)(Tree *);
  int (*SetKey)(Tree *, int);
  int (*GetHas_Right)(Tree *);
  int (*GetHas_Left)(Tree *);
  int (*SetHas_Left)(Tree *, int);
  int (*SetHas_Right)(Tree *, int);
  int (*Compare)(Tree *, int, int);
  int (*Insert)(Tree *, int);
  int (*Delete)(Tree *, int);
  int (*Remove)(Tree *, Tree *, Tree *);
  int (*RemoveRight)(Tree *, Tree *, Tree *);
  int (*RemoveLeft)(Tree *, Tree *, Tree *);
  int (*Search)(Tree *, int);
  int (*Print)(Tree *);
  int (*RecPrint)(Tree *, Tree *);
  int (*accept)(Tree *, Visitor *);
};

struct Visitor_vtable
{
  int (*visit)(Visitor *, Tree *);
};

struct MyVisitor_vtable
{
  int (*visit)(MyVisitor *, Tree *);
};


// methods
int TV_Start(struct TV *this)
{
  struct Tree * root;
  int  ntb;
  int  nti;
  struct MyVisitor * v;

  root = ((struct Tree*)(Tiger_new (&Tree_vtable_, sizeof(struct Tree))));
  ntb = this->vptr->Init(this, 16);
  ntb = this->vptr->Print(this);
  System_out_println (100000000);
  ntb = this->vptr->Insert(this, 8);
  ntb = this->vptr->Insert(this, 24);
  ntb = this->vptr->Insert(this, 4);
  ntb = this->vptr->Insert(this, 12);
  ntb = this->vptr->Insert(this, 20);
  ntb = this->vptr->Insert(this, 28);
  ntb = this->vptr->Insert(this, 14);
  ntb = this->vptr->Print(this);
  System_out_println (100000000);
  v = ((struct MyVisitor*)(Tiger_new (&MyVisitor_vtable_, sizeof(struct MyVisitor))));
  System_out_println (50000000);
  nti = this->vptr->accept(this, v);
  System_out_println (100000000);
  System_out_println (this->vptr->Search(this, 24));
  System_out_println (this->vptr->Search(this, 12));
  System_out_println (this->vptr->Search(this, 16));
  System_out_println (this->vptr->Search(this, 50));
  System_out_println (this->vptr->Search(this, 12));
  ntb = this->vptr->Delete(this, 12);
  ntb = this->vptr->Print(this);
  System_out_println (this->vptr->Search(this, 12));
  return 0;
}
int Tree_Init(struct Tree *this, int v_key)
{
  this->key = v_key;
  this->has_left = 0;
  this->has_right = 0;
  return 1;
}
int Tree_SetRight(struct Tree *this, struct Tree *rn)
{
  this->right = rn;
  return 1;
}
int Tree_SetLeft(struct Tree *this, struct Tree *ln)
{
  this->left = ln;
  return 1;
}
struct Tree *Tree_GetRight(struct Tree *this)
{
  return this->right;
}
struct Tree *Tree_GetLeft(struct Tree *this)
{
  return this->left;
}
int Tree_GetKey(struct Tree *this)
{
  return this->key;
}
int Tree_SetKey(struct Tree *this, int v_key)
{
  this->key = v_key;
  return 1;
}
int Tree_GetHas_Right(struct Tree *this)
{
  return this->has_right;
}
int Tree_GetHas_Left(struct Tree *this)
{
  return this->has_left;
}
int Tree_SetHas_Left(struct Tree *this, int val)
{
  this->has_left = val;
  return 1;
}
int Tree_SetHas_Right(struct Tree *this, int val)
{
  this->has_right = val;
  return 1;
}
int Tree_Compare(struct Tree *this, int num1, int num2)
{
  int  ntb;
  int  nti;

  ntb = 0;
  nti = num2 + 1;
  if (num1 < num2)
    ntb = 0;
  else if (!(num1 < nti))
    ntb = 0;
  else
    ntb = 1;
  return ntb;
}
int Tree_Insert(struct Tree *this, int v_key)
{
  struct Tree * new_node;
  int  ntb;
  struct Tree * current_node;
  int  cont;
  int  key_aux;

  new_node = ((struct Tree*)(Tiger_new (&Tree_vtable_, sizeof(struct Tree))));
  ntb = this->vptr->Init(this, v_key);
  current_node = this;
  cont = 1;
  while (cont)
  {
    key_aux = this->vptr->GetKey(this);
    if (v_key < key_aux)
    {
      if (this->vptr->GetHas_Left(this))
        current_node = this->vptr->GetLeft(this);
      else
      {
        cont = 0;
        ntb = this->vptr->SetHas_Left(this, 1);
        ntb = this->vptr->SetLeft(this, new_node);
      }
    }
    else
    {
      if (this->vptr->GetHas_Right(this))
        current_node = this->vptr->GetRight(this);
      else
      {
        cont = 0;
        ntb = this->vptr->SetHas_Right(this, 1);
        ntb = this->vptr->SetRight(this, new_node);
      }
    }
  }
  return 1;
}
int Tree_Delete(struct Tree *this, int v_key)
{
  struct Tree * current_node;
  struct Tree * parent_node;
  int  cont;
  int  found;
  int  ntb;
  int  is_root;
  int  key_aux;

  current_node = this;
  parent_node = this;
  cont = 1;
  found = 0;
  is_root = 1;
  while (cont)
  {
    key_aux = this->vptr->GetKey(this);
    if (v_key < key_aux)
      if (this->vptr->GetHas_Left(this))
      {
        parent_node = current_node;
        current_node = this->vptr->GetLeft(this);
      }
      else
        cont = 0;
    else if (key_aux < v_key)
      if (this->vptr->GetHas_Right(this))
      {
        parent_node = current_node;
        current_node = this->vptr->GetRight(this);
      }
      else
        cont = 0;
    else
    {
      if (is_root)
        if (!(this->vptr->GetHas_Right(this)) && !(this->vptr->GetHas_Left(this)))
          ntb = 1;
        else
          ntb = this->vptr->Remove(this, parent_node, current_node);
      else
        ntb = this->vptr->Remove(this, parent_node, current_node);
      found = 1;
      cont = 0;
    }
    is_root = 0;
  }
  return found;
}
int Tree_Remove(struct Tree *this, struct Tree *p_node, struct Tree *c_node)
{
  int  ntb;
  int  auxkey1;
  int  auxkey2;
  struct Tree * temp_2;

  if (this->vptr->GetHas_Left(this))
    ntb = this->vptr->RemoveLeft(this, p_node, c_node);
  else if (this->vptr->GetHas_Right(this))
    ntb = this->vptr->RemoveRight(this, p_node, c_node);
  else
  {
    auxkey1 = this->vptr->GetKey(this);
    auxkey2 = (temp_2=this->vptr->GetLeft(this), temp_2->vptr->GetKey(temp_2));
    if (this->vptr->Compare(this, auxkey1, auxkey2))
    {
      ntb = this->vptr->SetLeft(this, this->my_null);
      ntb = this->vptr->SetHas_Left(this, 0);
    }
    else
    {
      ntb = this->vptr->SetRight(this, this->my_null);
      ntb = this->vptr->SetHas_Right(this, 0);
    }
  }
  return 1;
}
int Tree_RemoveRight(struct Tree *this, struct Tree *p_node, struct Tree *c_node)
{
  int  ntb;
  struct Tree * temp_3;

  while (this->vptr->GetHas_Right(this))
  {
    ntb = this->vptr->SetKey(this, (temp_3=this->vptr->GetRight(this), temp_3->vptr->GetKey(temp_3)));
    p_node = c_node;
    c_node = this->vptr->GetRight(this);
  }
  ntb = this->vptr->SetRight(this, this->my_null);
  ntb = this->vptr->SetHas_Right(this, 0);
  return 1;
}
int Tree_RemoveLeft(struct Tree *this, struct Tree *p_node, struct Tree *c_node)
{
  int  ntb;
  struct Tree * temp_4;

  while (this->vptr->GetHas_Left(this))
  {
    ntb = this->vptr->SetKey(this, (temp_4=this->vptr->GetLeft(this), temp_4->vptr->GetKey(temp_4)));
    p_node = c_node;
    c_node = this->vptr->GetLeft(this);
  }
  ntb = this->vptr->SetLeft(this, this->my_null);
  ntb = this->vptr->SetHas_Left(this, 0);
  return 1;
}
int Tree_Search(struct Tree *this, int v_key)
{
  struct Tree * current_node;
  int  ifound;
  int  cont;
  int  key_aux;

  current_node = this;
  cont = 1;
  ifound = 0;
  while (cont)
  {
    key_aux = this->vptr->GetKey(this);
    if (v_key < key_aux)
      if (this->vptr->GetHas_Left(this))
        current_node = this->vptr->GetLeft(this);
      else
        cont = 0;
    else if (key_aux < v_key)
      if (this->vptr->GetHas_Right(this))
        current_node = this->vptr->GetRight(this);
      else
        cont = 0;
    else
    {
      ifound = 1;
      cont = 0;
    }
  }
  return ifound;
}
int Tree_Print(struct Tree *this)
{
  int  ntb;
  struct Tree * current_node;

  current_node = this;
  ntb = this->vptr->RecPrint(this, current_node);
  return 1;
}
int Tree_RecPrint(struct Tree *this, struct Tree *node)
{
  int  ntb;

  if (this->vptr->GetHas_Left(this))
  {
    ntb = this->vptr->RecPrint(this, this->vptr->GetLeft(this));
  }
  else
    ntb = 1;
  System_out_println (this->vptr->GetKey(this));
  if (this->vptr->GetHas_Right(this))
  {
    ntb = this->vptr->RecPrint(this, this->vptr->GetRight(this));
  }
  else
    ntb = 1;
  return 1;
}
int Tree_accept(struct Tree *this, struct Visitor *v)
{
  int  nti;

  System_out_println (333);
  nti = this->vptr->visit(this, this);
  return 0;
}
int Visitor_visit(struct Visitor *this, struct Tree *n)
{
  int  nti;

  if (this->vptr->GetHas_Right(this))
  {
    this->r = this->vptr->GetRight(this);
    nti = this->vptr->accept(this, this);
  }
  else
    nti = 0;
  if (this->vptr->GetHas_Left(this))
  {
    this->l = this->vptr->GetLeft(this);
    nti = this->vptr->accept(this, this);
  }
  else
    nti = 0;
  return 0;
}
int MyVisitor_visit(struct MyVisitor *this, struct Tree *n)
{
  int  nti;

  if (this->vptr->GetHas_Right(this))
  {
    this->r = this->vptr->GetRight(this);
    nti = this->vptr->accept(this, this);
  }
  else
    nti = 0;
  System_out_println (this->vptr->GetKey(this));
  if (this->vptr->GetHas_Left(this))
  {
    this->l = this->vptr->GetLeft(this);
    nti = this->vptr->accept(this, this);
  }
  else
    nti = 0;
  return 0;
}

// vtables
struct TreeVisitor_vtable TreeVisitor_vtable_ = 
{
};

struct TV_vtable TV_vtable_ = 
{
  TV_Start
};

struct Tree_vtable Tree_vtable_ = 
{
  Tree_Init,
  Tree_SetRight,
  Tree_SetLeft,
  Tree_GetRight,
  Tree_GetLeft,
  Tree_GetKey,
  Tree_SetKey,
  Tree_GetHas_Right,
  Tree_GetHas_Left,
  Tree_SetHas_Left,
  Tree_SetHas_Right,
  Tree_Compare,
  Tree_Insert,
  Tree_Delete,
  Tree_Remove,
  Tree_RemoveRight,
  Tree_RemoveLeft,
  Tree_Search,
  Tree_Print,
  Tree_RecPrint,
  Tree_accept
};

struct Visitor_vtable Visitor_vtable_ = 
{
  Visitor_visit
};

struct MyVisitor_vtable MyVisitor_vtable_ = 
{
  MyVisitor_visit
};


// main method
int Tiger_main ()
{
  struct TV *temp_1;
  System_out_println ((temp_1=((struct TV*)(Tiger_new (&TV_vtable_, sizeof(struct TV)))), temp_1->vptr->Start(temp_1)));
}




