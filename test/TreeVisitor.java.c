// This is automatically generated by the Tiger compiler.
// Do NOT modify!

//----------------structures-----------------
struct TreeVisitor
{
  struct TreeVisitor_vtable *vptr;
};
struct TV
{
  struct TV_vtable *vptr;
};
struct Tree
{
  struct Tree_vtable *vptr;
  struct Tree * left;
  struct Tree * right;
  int  key;
  int  has_left;
  int  has_right;
  struct Tree * my_null;
};
struct Visitor
{
  struct Visitor_vtable *vptr;
  struct Tree * l;
  struct Tree * r;
};
struct MyVisitor
{
  struct MyVisitor_vtable *vptr;
  struct Tree * l;
  struct Tree * r;
};
//----------------vtables structures-----------------
struct TreeVisitor_vtable
{
};

struct TV_vtable
{
  int  (*Start)();
};

struct Tree_vtable
{
  int  (*Init)();
  int  (*SetRight)();
  int  (*SetLeft)();
  struct Tree * (*GetRight)();
  struct Tree * (*GetLeft)();
  int  (*GetKey)();
  int  (*SetKey)();
  int  (*GetHas_Right)();
  int  (*GetHas_Left)();
  int  (*SetHas_Left)();
  int  (*SetHas_Right)();
  int  (*Compare)();
  int  (*Insert)();
  int  (*Delete)();
  int  (*Remove)();
  int  (*RemoveRight)();
  int  (*RemoveLeft)();
  int  (*Search)();
  int  (*Print)();
  int  (*RecPrint)();
  int  (*accept)();
};

struct Visitor_vtable
{
  int  (*visit)();
};

struct MyVisitor_vtable
{
  int  (*visit)();
};


//----------------methods declarations--------------------
int TV_Start(struct TV *this);
int Tree_Init(struct Tree *this, int v_key);
int Tree_SetRight(struct Tree *this, struct Tree *rn);
int Tree_SetLeft(struct Tree *this, struct Tree *ln);
struct Tree *Tree_GetRight(struct Tree *this);
struct Tree *Tree_GetLeft(struct Tree *this);
int Tree_GetKey(struct Tree *this);
int Tree_SetKey(struct Tree *this, int v_key);
int Tree_GetHas_Right(struct Tree *this);
int Tree_GetHas_Left(struct Tree *this);
int Tree_SetHas_Left(struct Tree *this, int val);
int Tree_SetHas_Right(struct Tree *this, int val);
int Tree_Compare(struct Tree *this, int num1, int num2);
int Tree_Insert(struct Tree *this, int v_key);
int Tree_Delete(struct Tree *this, int v_key);
int Tree_Remove(struct Tree *this, struct Tree *p_node, struct Tree *c_node);
int Tree_RemoveRight(struct Tree *this, struct Tree *p_node, struct Tree *c_node);
int Tree_RemoveLeft(struct Tree *this, struct Tree *p_node, struct Tree *c_node);
int Tree_Search(struct Tree *this, int v_key);
int Tree_Print(struct Tree *this);
int Tree_RecPrint(struct Tree *this, struct Tree *node);
int Tree_accept(struct Tree *this, struct Visitor *v);
int Visitor_visit(struct Visitor *this, struct Tree *n);
int MyVisitor_visit(struct MyVisitor *this, struct Tree *n);

//-----------------vtables------------------
struct TreeVisitor_vtable TreeVisitor_vtable_ = 
{
};

struct TV_vtable TV_vtable_ = 
{
  TV_Start
};

struct Tree_vtable Tree_vtable_ = 
{
  Tree_Init,
  Tree_SetRight,
  Tree_SetLeft,
  Tree_GetRight,
  Tree_GetLeft,
  Tree_GetKey,
  Tree_SetKey,
  Tree_GetHas_Right,
  Tree_GetHas_Left,
  Tree_SetHas_Left,
  Tree_SetHas_Right,
  Tree_Compare,
  Tree_Insert,
  Tree_Delete,
  Tree_Remove,
  Tree_RemoveRight,
  Tree_RemoveLeft,
  Tree_Search,
  Tree_Print,
  Tree_RecPrint,
  Tree_accept
};

struct Visitor_vtable Visitor_vtable_ = 
{
  Visitor_visit
};

struct MyVisitor_vtable MyVisitor_vtable_ = 
{
  MyVisitor_visit
};


//-----------------methods------------------
int TV_Start(struct TV *this)
{
  struct Tree * root;
  int  ntb;
  int  nti;
  struct MyVisitor * v;

  root = ((struct Tree*)(Tiger_new (&Tree_vtable_, sizeof(struct Tree))));
  ntb = root->vptr->Init(root, 16);
  ntb = root->vptr->Print(root);
  System_out_println (100000000);
  ntb = root->vptr->Insert(root, 8);
  ntb = root->vptr->Insert(root, 24);
  ntb = root->vptr->Insert(root, 4);
  ntb = root->vptr->Insert(root, 12);
  ntb = root->vptr->Insert(root, 20);
  ntb = root->vptr->Insert(root, 28);
  ntb = root->vptr->Insert(root, 14);
  ntb = root->vptr->Print(root);
  System_out_println (100000000);
  v = ((struct MyVisitor*)(Tiger_new (&MyVisitor_vtable_, sizeof(struct MyVisitor))));
  System_out_println (50000000);
  nti = root->vptr->accept(root, v);
  System_out_println (100000000);
  System_out_println (root->vptr->Search(root, 24));
  System_out_println (root->vptr->Search(root, 12));
  System_out_println (root->vptr->Search(root, 16));
  System_out_println (root->vptr->Search(root, 50));
  System_out_println (root->vptr->Search(root, 12));
  ntb = root->vptr->Delete(root, 12);
  ntb = root->vptr->Print(root);
  System_out_println (root->vptr->Search(root, 12));
  return 0;
}
int Tree_Init(struct Tree *this, int v_key)
{
  this->key = v_key;
  this->has_left = 0;
  this->has_right = 0;
  return 1;
}
int Tree_SetRight(struct Tree *this, struct Tree *rn)
{
  this->right = rn;
  return 1;
}
int Tree_SetLeft(struct Tree *this, struct Tree *ln)
{
  this->left = ln;
  return 1;
}
struct Tree *Tree_GetRight(struct Tree *this)
{
  return this->right;
}
struct Tree *Tree_GetLeft(struct Tree *this)
{
  return this->left;
}
int Tree_GetKey(struct Tree *this)
{
  return this->key;
}
int Tree_SetKey(struct Tree *this, int v_key)
{
  this->key = v_key;
  return 1;
}
int Tree_GetHas_Right(struct Tree *this)
{
  return this->has_right;
}
int Tree_GetHas_Left(struct Tree *this)
{
  return this->has_left;
}
int Tree_SetHas_Left(struct Tree *this, int val)
{
  this->has_left = val;
  return 1;
}
int Tree_SetHas_Right(struct Tree *this, int val)
{
  this->has_right = val;
  return 1;
}
int Tree_Compare(struct Tree *this, int num1, int num2)
{
  int  ntb;
  int  nti;

  ntb = 0;
  nti = num2 + 1;
  if (num1 < num2)
    ntb = 0;
  else if (!(num1 < nti))
    ntb = 0;
  else
    ntb = 1;
  return ntb;
}
int Tree_Insert(struct Tree *this, int v_key)
{
  struct Tree * new_node;
  int  ntb;
  struct Tree * current_node;
  int  cont;
  int  key_aux;

  new_node = ((struct Tree*)(Tiger_new (&Tree_vtable_, sizeof(struct Tree))));
  ntb = new_node->vptr->Init(new_node, v_key);
  current_node = this;
  cont = 1;
  while (cont)
  {
    key_aux = current_node->vptr->GetKey(current_node);
    if (v_key < key_aux)
    {
      if (current_node->vptr->GetHas_Left(current_node))
        current_node = current_node->vptr->GetLeft(current_node);
      else
      {
        cont = 0;
        ntb = current_node->vptr->SetHas_Left(current_node, 1);
        ntb = current_node->vptr->SetLeft(current_node, new_node);
      }
    }
    else
    {
      if (current_node->vptr->GetHas_Right(current_node))
        current_node = current_node->vptr->GetRight(current_node);
      else
      {
        cont = 0;
        ntb = current_node->vptr->SetHas_Right(current_node, 1);
        ntb = current_node->vptr->SetRight(current_node, new_node);
      }
    }
  }
  return 1;
}
int Tree_Delete(struct Tree *this, int v_key)
{
  struct Tree * current_node;
  struct Tree * parent_node;
  int  cont;
  int  found;
  int  ntb;
  int  is_root;
  int  key_aux;

  current_node = this;
  parent_node = this;
  cont = 1;
  found = 0;
  is_root = 1;
  while (cont)
  {
    key_aux = current_node->vptr->GetKey(current_node);
    if (v_key < key_aux)
      if (current_node->vptr->GetHas_Left(current_node))
      {
        parent_node = current_node;
        current_node = current_node->vptr->GetLeft(current_node);
      }
      else
        cont = 0;
    else if (key_aux < v_key)
      if (current_node->vptr->GetHas_Right(current_node))
      {
        parent_node = current_node;
        current_node = current_node->vptr->GetRight(current_node);
      }
      else
        cont = 0;
    else
    {
      if (is_root)
        if (!(current_node->vptr->GetHas_Right(current_node)) && !(current_node->vptr->GetHas_Left(current_node)))
          ntb = 1;
        else
          ntb = this->vptr->Remove(this, parent_node, current_node);
      else
        ntb = this->vptr->Remove(this, parent_node, current_node);
      found = 1;
      cont = 0;
    }
    is_root = 0;
  }
  return found;
}
int Tree_Remove(struct Tree *this, struct Tree *p_node, struct Tree *c_node)
{
  int  ntb;
  int  auxkey1;
  int  auxkey2;

  if (c_node->vptr->GetHas_Left(c_node))
    ntb = this->vptr->RemoveLeft(this, p_node, c_node);
  else if (c_node->vptr->GetHas_Right(c_node))
    ntb = this->vptr->RemoveRight(this, p_node, c_node);
  else
  {
    auxkey1 = c_node->vptr->GetKey(c_node);
    auxkey2 = p_node->vptr->GetLeft(p_node)->vptr->GetKey(p_node->vptr->GetLeft(p_node));
    if (this->vptr->Compare(this, auxkey1, auxkey2))
    {
      ntb = p_node->vptr->SetLeft(p_node, this->my_null);
      ntb = p_node->vptr->SetHas_Left(p_node, 0);
    }
    else
    {
      ntb = p_node->vptr->SetRight(p_node, this->my_null);
      ntb = p_node->vptr->SetHas_Right(p_node, 0);
    }
  }
  return 1;
}
int Tree_RemoveRight(struct Tree *this, struct Tree *p_node, struct Tree *c_node)
{
  int  ntb;

  while (c_node->vptr->GetHas_Right(c_node))
  {
    ntb = c_node->vptr->SetKey(c_node, c_node->vptr->GetRight(c_node)->vptr->GetKey(c_node->vptr->GetRight(c_node)));
    p_node = c_node;
    c_node = c_node->vptr->GetRight(c_node);
  }
  ntb = p_node->vptr->SetRight(p_node, this->my_null);
  ntb = p_node->vptr->SetHas_Right(p_node, 0);
  return 1;
}
int Tree_RemoveLeft(struct Tree *this, struct Tree *p_node, struct Tree *c_node)
{
  int  ntb;

  while (c_node->vptr->GetHas_Left(c_node))
  {
    ntb = c_node->vptr->SetKey(c_node, c_node->vptr->GetLeft(c_node)->vptr->GetKey(c_node->vptr->GetLeft(c_node)));
    p_node = c_node;
    c_node = c_node->vptr->GetLeft(c_node);
  }
  ntb = p_node->vptr->SetLeft(p_node, this->my_null);
  ntb = p_node->vptr->SetHas_Left(p_node, 0);
  return 1;
}
int Tree_Search(struct Tree *this, int v_key)
{
  struct Tree * current_node;
  int  ifound;
  int  cont;
  int  key_aux;

  current_node = this;
  cont = 1;
  ifound = 0;
  while (cont)
  {
    key_aux = current_node->vptr->GetKey(current_node);
    if (v_key < key_aux)
      if (current_node->vptr->GetHas_Left(current_node))
        current_node = current_node->vptr->GetLeft(current_node);
      else
        cont = 0;
    else if (key_aux < v_key)
      if (current_node->vptr->GetHas_Right(current_node))
        current_node = current_node->vptr->GetRight(current_node);
      else
        cont = 0;
    else
    {
      ifound = 1;
      cont = 0;
    }
  }
  return ifound;
}
int Tree_Print(struct Tree *this)
{
  int  ntb;
  struct Tree * current_node;

  current_node = this;
  ntb = this->vptr->RecPrint(this, current_node);
  return 1;
}
int Tree_RecPrint(struct Tree *this, struct Tree *node)
{
  int  ntb;

  if (node->vptr->GetHas_Left(node))
  {
    ntb = this->vptr->RecPrint(this, node->vptr->GetLeft(node));
  }
  else
    ntb = 1;
  System_out_println (node->vptr->GetKey(node));
  if (node->vptr->GetHas_Right(node))
  {
    ntb = this->vptr->RecPrint(this, node->vptr->GetRight(node));
  }
  else
    ntb = 1;
  return 1;
}
int Tree_accept(struct Tree *this, struct Visitor *v)
{
  int  nti;

  System_out_println (333);
  nti = v->vptr->visit(v, this);
  return 0;
}
int Visitor_visit(struct Visitor *this, struct Tree *n)
{
  int  nti;

  if (n->vptr->GetHas_Right(n))
  {
    this->r = n->vptr->GetRight(n);
    nti = this->r->vptr->accept(this->r, this);
  }
  else
    nti = 0;
  if (n->vptr->GetHas_Left(n))
  {
    this->l = n->vptr->GetLeft(n);
    nti = this->l->vptr->accept(this->l, this);
  }
  else
    nti = 0;
  return 0;
}
int MyVisitor_visit(struct MyVisitor *this, struct Tree *n)
{
  int  nti;

  if (n->vptr->GetHas_Right(n))
  {
    this->r = n->vptr->GetRight(n);
    nti = this->r->vptr->accept(this->r, this);
  }
  else
    nti = 0;
  System_out_println (n->vptr->GetKey(n));
  if (n->vptr->GetHas_Left(n))
  {
    this->l = n->vptr->GetLeft(n);
    nti = this->l->vptr->accept(this->l, this);
  }
  else
    nti = 0;
  return 0;
}

//-----------------main method------------------
int Tiger_main ()
{
  struct TV *temp_1;
  System_out_println ((temp_1=((struct TV*)(Tiger_new (&TV_vtable_, sizeof(struct TV)))), temp_1->vptr->Start(temp_1)));
}




